# Cheetsheet того, що варто провірити на тренувальному турі
Короткий документ який вам поможе трохи розібратись з системою та у разі чого не панікувати, а рішати задачу =)

## Використання \_\_int128
### Що це таке?
Що таке `__int128`? Це цілочисельний тип даних який використовує `128` бітів, тобто як два `long long`'и, таким чином максимальне значення, що може зберігатись у ньому (за нявності від'ємних чисел) це трошки більше ніж `1.7*10^38`
### Порівняння з іншими типами даних
| Оголошення типу | ~Мін | ~Макс | Мін | Макс |
| --- | --- | --- | --- | --- |
| `int` | `-2*10^9` | `2*10^9` | `-2147483648` | `2147483647` |
| `long long` | `-9*10^18` | `9*10^18` | `-9223372036854775808` | `9223372036854775807` |
| `__int128` | `-1.7*10^38` | `1.7*10^38` | `-170141183460469231731687303715884105728` | `170141183460469231731687303715884105727` |
| `unsigned int` | `0` | `4*10^9` | `0` | `4294967295` |
| `unsigned long long` | `0` | `1.8*10^19` | `0` | `18446744073709551615` |
| `__uint128` | `0` | `3.4*10^38` | `0` | `340282366920938463463374607431768211455` |
### Реалізація
Для реалізації `__int128` потрібно просто замінити `long long` або `int` на `__int128` (зверніть увагу, що це два нижні підчеркування), або ж `unsigned long long` чи `unsigned int` на `__uint128`. 
### Ввід/вивід
Особливістю роботи з `__int128` є те, що його **не можна** вводити та виводити, тільки використовувавати як проміжне значення. Тому, якщо вводити його зазвичай не треба (зокрема я не бачив задач де ввід числа з 38-цифр), то для виводу іноді буває корисний наступний код:
```c++
string conv_int_to_string(__int128 a){
  string s; //створюємо рядок-відповідь
  bool minus = (a<0); //перевіряємо чи число менше 0
  if(minus) a=-a; //якщо менше, то інвертуємо його, потім в кінці додамо мінус на початок
  while(a){ //поки число не 0, беремо його останню цифру і закидаємо в кінець рядка s
    s.push_back('0'+(a%10)); 
    a/=10;
  }
  //наразі в рядку s у нас уже є всі цифри числа, тільки в розвернутому вигляді
  if(minus) s.push_back('-'); //якщо число від'ємне, то додаємо мінус в кінець
  reverse(s.begin(), s.end()); //розвертаємо рядок (якщо ми додавали мінус то тепер він став на початку і все ок)
  if(s.empty()) s.push_back('0'); //може бути варіант, що а спершу було рівне 0, в такому разі наш рядок був би пустим, тому якщо він пустий то закинемо у нього 0 щоб він не був пустим
  return s; //повернемо рядок
}

int main(){
  __int128 var = 123;
  cout<<conv_int_to_string(var);
}
```

## Компіляція в консолі
### Для чого це?
Це вам може бути корисно у разі проблеми з CodeBlocks або якщо ви не вмієте з градерами працювати. Обов'язково протестуйте чи у вас все виходить на трентурі, щоб в разі чого вам помогли
### Текстова інструкція для одного файлу
1. Відкриваєте термінал у папці з файлом, який треба скомпілити (файловий менеджер -> права клавіша миші -> open in terminal)
2. В терміналі прописуєте `g++ -std=c++17 -o file1 file2.cpp`
   - `g++` це назва команди
   - `-std=c++17` це треба запам'ятати, задає версію C++ на 17 (якщо я не помиляюсь, на компах ця буде найновіша підтримувана)
   - `-o file1` в який файл скомпілювати все це
   - `file2.cpp` назва файлу з кодом
3. Щоб запустити тепер (якщо під час компіляції не вискочило **error**) треба написати `.\file1`, де `file1` таке саме як в попередній команді
### Текстова інструкція для задач з градерами
1. Відкриваєте термінал у папці з файлами, які треба скомпілити (файловий менеджер -> права клавіша миші -> open in terminal)
2. В терміналі прописуєте `g++ -std=c++17 -o file1 file2.cpp grader.cpp`
   - `g++` це назва команди
   - `-std=c++17` згадайте з попереднього списку
   - `-o file1` теж згадайте
   - `file2.cpp` назва файлу з кодом
   - `grader.cpp` назва файлу-градера
3. Щоб запустити тепер (якщо під час компіляції не вискочило **error**) треба написати `.\file1`, де `file1` таке саме як в попередній команді

## Версія С++ в CodeBlocks
CodeBlocks -> Settings -> Compiler -> Other Compiler Options -> дописати `-std=c++17` -> OK

![Screenshot from 2022-10-14 23-48-17](https://user-images.githubusercontent.com/17510629/195949161-75227d9a-dc23-4e6f-8001-dddb24853882.png)

![Screenshot from 2022-10-14 23-48-36](https://user-images.githubusercontent.com/17510629/195949172-40f4c79b-0ee5-4710-9bf6-800329b03a4b.png)

![Screenshot from 2022-10-14 23-48-45](https://user-images.githubusercontent.com/17510629/195949194-55706a98-8ddc-41be-b1db-760bf37723b4.png)

![Screenshot from 2022-10-14 23-48-52](https://user-images.githubusercontent.com/17510629/195949202-55f223a2-e2ea-4be0-9705-486365ff51e7.png)

## Дебагер
### Нащо
Часто буває корисним, але щоб з ним розібратись треба з розуму зійти, тому розкажу базові функції, далі за бажання на трентурі спитаєтесь у когось з лідерів
### Передумови
Для використання дебагера, потрібно кодити в проєктах (тобто в кодеблоксі створити проєкт і там кодити, а не просто створити і відкрити файл)
### Текст
Для початку потрібно створити breakpoint-и. Іх ставлять на певні рядки коду. Це така штука, яка означає що перед виконанням цього рядка, виконання всієї програми загалом призупиниться. Ставлять їх, натискаючи мишкою трохи правіше номера відповідного рядка. Тепер потрібно запустити програму, для цього треба натиснути на червоний трикутник. У вас має появитись знизу така панелька де багато тексту і можна щось вводити. Туди можна вводити різноманітні команди, коли виконання програми зупинилось на певному breakpoint-і. Вам з усіх команд потрібна лише `p`. Пишете `p var` і воно вам виводить значення змінної `var` в даних момент виконання. Можна також написати `p func(a, b, c)` щоб запустити фукнцію `func`, ну короче все як і просто при заданні змінної якоїсь. Додатково можна відкрити `Debug -> Debugging Windows -> Watches` щоб список локальних змінних був зразу перед очима. Щоб перейти до наступного брейкпоінта, треба знову натиснути червоний трикутник, можна просто перейти до наступного рядка натиснувши `next line`. Щоб вийти з дебагера треба натиснути `stop debugger`. Загалом дебагер це дуже зручно всім рекомендую як мінімум з цим (~погратись~)розібратись.
### Скріншоти
![image](https://user-images.githubusercontent.com/17510629/195950498-49a93810-cb95-4810-9120-d20b64ff61fc.png)

*десь так натискати, щоб створити брейкпоінт*

![image](https://user-images.githubusercontent.com/17510629/195950533-bf4b8792-1e25-4a5a-9cc2-190553bf6819.png)

*запускати/переходити до наступного брейкпоінта цим червоним трикутником*

![image](https://user-images.githubusercontent.com/17510629/195950692-25ca56b9-85d9-4234-8da2-7b1aebeaffca.png)

*на цю штуку завжди Yes відповідайте і не парьтесь*

![image](https://user-images.githubusercontent.com/17510629/195950753-aa9f0d35-caff-4757-b72b-5173e3573076.png)

*тут вводити команди*

![image](https://user-images.githubusercontent.com/17510629/195950803-8bb6a8a9-0c5b-4968-8c04-5e482bc265f6.png)

*жовтий трикутник показує де зараз програма виконується*

![image](https://user-images.githubusercontent.com/17510629/195950841-63ee4525-3f63-4970-994f-239292e954d4.png)

*на цьому ж етапі приклад виконання одної команди*

![image](https://user-images.githubusercontent.com/17510629/195950893-3570f147-0b3e-4315-a265-52e14e5c8892.png)

*та інших двох*

![image](https://user-images.githubusercontent.com/17510629/195950954-81bd9905-a74e-4881-8cdd-f76114769828.png)

*ось так виглядають watches*

![image](https://user-images.githubusercontent.com/17510629/195951032-d868a371-1c85-466f-867a-dac3b9316020.png)

*і ось кнопка `next line`*

![image](https://user-images.githubusercontent.com/17510629/195951065-024af606-90af-4156-872e-cf6369c6e050.png)

*цією штукою дебагер зупиняють*

## Автозберігання
### Нащо
На випадок проблем з компом щоб файл завжди сам зберігався (кожної хвилини)
### Інструкція
Settings -> Enviroment -> Autosave (в меню зліва) -> Все вмикаємо, ставимо на 1 хв і ставимо метод `Save to Original File`

![image](https://user-images.githubusercontent.com/17510629/195951814-fc659732-27b8-40e5-a7d4-b0443b68316f.png)

## Ordered set
### Нащо
Структура, яка бистро вміє рахувати кількість елементів менших за `x` в сеті або находити `i`-ий елемент в сеті
### Як юзати
```c++
...
#include <ext/pb_ds/assoc_container.hpp>
...
using namespace __gnu_pbds;
using yree=tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>;
...
yree sz;
sz.insert(x); //додати x в сет
sz.order_of_key(x); //кількість елементів менше x в сеті
sz.find_by_order(x); //вказівник на х-тий елемент в сеті
sz.erase(sz.find_by_order(x)); //удалити х-тий елемент в сеті
sz.erase(sz.find_by_order(sz.order_of_key(x))); //удалити елемент х в сеті (точніше перший, який більше-рівне х)
sz.find_by_order(sz.order_of_key(x)) != sz.end(); //перевірити чи існує елемент більше-рівне х в сеті
*sz.find_by_order(x); //значення х-того елемента в сеті
*sz.find_by_order(sz.order_of_key(x)); //значення першого елемента більше-рівне х в сеті
```
### Як запам'ятати
Просто заучити, останнє слово там де `using yree=...` я запам'ятав по першим буквам (tosnu), і за останні 3 роки ні разу не забув.
### Варіації
#### Щоб в сеті тримати від більшого до меншого
Треба замінити `less<int>` на `greater<int>`
#### Апгрейд до мультисета
Треба замінити `less<int>` на `less_equal<int>` або `greater<int>` на `greater_equal<int>`. `sz.order_of_key` все ще буде повертати кількість **строго** менших(більших), описаний мною `erase` буде видаляти одне входження елементу. Щоб удалити всі входження слід написати `sz.erase(x)`.
